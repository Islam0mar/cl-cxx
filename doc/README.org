* Introduction

  This library provides an interface to C++ from Common Lisp.

  As [[https://cffi.common-lisp.dev/][CFFI]] is normally used for C code, there are no builtin functions
  to deal with C++ extensions from Common Lisp like class definitions,
  their instantiation, accessing and defining member functions,
  etc. [[https://github.com/Islam0mar/cl-cxx][cl-cxx]] is an attempt to step in and facilitate easy interfacing
  from Common Lisp to C​++ libs. It uses CFFI under the hood, but
  generates its definitions automagically from C​++ code written by
  the user.

  The code was inspired by Julia's [[https://github.com/JuliaInterop/CxxWrap.jl][CxxWrap]] and provides a similar
  functionality as python's [[https://github.com/pybind/pybind11][pybind11]] for the Common Lisp community.
  
* Architecture

** Provided parts

  The provided architecture consists of two parts:

  - [[https://github.com/Islam0mar/CLCXX][CLCXX]]

     A C​++ library which gets compiled once and installed systemwide,
     visible by the C++ toolchain.

  - [[https://github.com/Islam0mar/cl-cxx][cl-cxx]]

    The Common Lisp part, which translates the definitions of the
    custom C​++ library (see below) to CFFI code suitable to be used
    directly from Common Lisp.

  In addition existing C++ Libraries and their header files can be
  included in case they are targeted.
  
** Custom parts

   There are also two user-defined parts:

  - A custom C​++ library

    This contains the C​++ code to be exposed to Lisp, custom
    definitions or glue code to existing libraries, the API bindings,
    package name definitions for the Lisp side, the Lisp names of
    functions, methods, member functions, etc...
  
  - The custom Common Lisp code

    This contains the code to load the foreign libraries and
    initialize the cl-cxx system and package definitions from the C++
    lib to be accessible by Lisp. In addition this code can also
    contain macros and such to make the API "lispier", as it is common
    for CFFI related packages.

  The following diagram shows the relation of the different parts:
  
  [[./block-diagram.svg]]

  
  Note that with this design, the definition of functions, structs,
  etc. is *not* done by the user on the Lisp side, as it is the case
  when working with standard CFFI directly, but rather on the C​++
  side, with the translations, name mangling, etc. done automatically
  by CLCXX and cl-cxx. The two Common Lisp functions taking care of
  translating the compiled C​++ definitions into cffi are =(cxx:init)=
  and =(cxx:add-package...)=

* Examples

  The =example= folder contains a full example. It can be used as a
  skeleton for a new project. The necessary steps to make the example
  work are explained using linux commands. Please translate them into
  the corresponding commands for your OS.

** Setup
  - Copy the folder with all contents to a location of your choice:

#+BEGIN_SRC bash

$ cp -R examples /tmp/
$ cd /tmp/examples

#+END_SRC

The necessary files for the custom C++ library are located in the
subfolder =custom-lib=. If additional libs are needed, put their
header files into the =custom-lib/include= folder or optionally into
=custom-lib/modules= and add their reference to the file
=/tmp/example/custom-lib/CMakeLists.txt= as in a normal C++ project.

** The C​++ source file

   The C​++ source file is located in =custom-lib/src/my-lib.cpp= Here
   are its contents:

#+BEGIN_SRC c

#include <string>
#include "clcxx/clcxx.hpp"

// standard C function definitions:

std::string greet() { return "Hello, World"; }
int Int(int x) { return x + 100; }
float Float(float y) { return y + 100.34; }
auto gr(std::complex<float> x) { return x; }
std::string hi(char* s) { return std::string("hi, " + std::string(s)); }
void ref_int(int& x) { x += 30; }

// C++ class definition with members and method: class xx { public:

class xx {
 public:
  xx(int xx, int yy) : y(yy), x(xx) {}
  std::string greet() { return "Hello, World"; }
  int y;
  int x;
};
void ref_class(xx& x) { x.y = 1000000; }

// definitions of the API exposure to Common Lisp:

CLCXX_PACKAGE TEST(clcxx::Package& pack) {
  pack.defun("hi", F_PTR(&hi));
  pack.defun("test-int", F_PTR(&Int));
  pack.defun("greet", F_PTR(&greet));
  pack.defun("test-float", F_PTR(&Float));
  pack.defun("test-complex", F_PTR(&gr));
  pack.defun("ref-int", F_PTR(&ref_int));
  pack.defun("ref-class", F_PTR(&ref_class));
  pack.defclass<xx, false>("xx")
    .member("y", &xx::y)
    .defmethod("foo", F_PTR(&xx::greet))
    .defmethod("foo.x", F_PTR([](xx x){return x.x;}))
    .constructor<int, int>("create-xx");
}

#+END_SRC


*** Definitions of the API exposure to Common Lisp

    The API exposure to Common Lisp happens inside a =CLCXX_PACKAGE=
    block of the C++ file. After compilation of the lib and its
    loading from Common Lisp, all the definitions get pulled into a
    custom, newly created Common Lisp package with the command
    =add-package=. The command takes two arguments: The name defined
    in the C++ file ("TEST" in the example) and the name of the Common
    Lisp package to use ("CL-TEST" in the example).

    The =CLCXX_PACKAGE= block defines the bindings of the C++
    functions, classes, methods, members and constructors to Common
    lisp functions. Everything *not* defined here will not be visible
    by Common Lisp.
    
#+BEGIN_SRC c
CLCXX_PACKAGE TEST(clcxx::Package& pack) {
// ...
}
#+END_SRC

Defines the package named =TEST=, using the package pointer =pack=.

#+BEGIN_SRC c
  pack.defun("greet", F_PTR(&greet));
#+END_SRC

Defines the Common Lisp function =#'cl-test:greet= to call the C++
function =greet=.

#+BEGIN_SRC c
  pack.defclass<xx, false>("xx")
#+END_SRC

Defines a class framework of the C++ class =xx= for Common Lisp.

#+BEGIN_SRC c
  .member("y", &xx::y)
#+END_SRC

Define the member =#'cl-test:y=

#+BEGIN_SRC c
.defmethod("cl-name", fn-pointer c-method)
#+END_SRC

the class's setter and getter functions are also defined this way:

#+BEGIN_SRC c
.defmethod("foo.x", F_PTR([](xx x){return x.x;}))
#+END_SRC

defines the methods #'cl-test:foo.x as getter and
#'cl-test:foo.x.set as setter for the member x of class xx.

.constructor defines a constructor function for Common-lisp

#+BEGIN_SRC c
.constructor<int, int>("create-xx")
#+END_SRC

defines a Common Lisp
constructor function #'cl-test:create-xx with two integer
arguments.



** Building the Library

#+BEGIN_SRC bash

$ cd /tmp/examples/my-lib
$ mkdir build
$ cd build
$ cmake ..
$ make

#+END_SRC

This should compile a shared library named =myLib.so= (maybe with
another extension according to your OS) and put it into the folder
=/tmp/example/my-lib/lib/=

  Following is a full example
Examples - 2 or 3 end to end examples, with extensive documentation

* Future Direction

  none yet...
  
* Help Wanted

  please send bug reports, code to custom libs using the system,
  etc. for expanding the user base.

  - The first argument of add-package is the name of the Package
  defined with =CLCXX​_PACKAGE= in the cpp file.

- The second argument of add-package is the name of the common-lisp
  package to define.

